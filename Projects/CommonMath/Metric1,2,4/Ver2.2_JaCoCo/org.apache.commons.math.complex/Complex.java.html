<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Complex.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math.complex</a> &gt; <span class="el_source">Complex.java</span></div><h1>Complex.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math.complex;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.math.FieldElement;
import org.apache.commons.math.MathRuntimeException;
import org.apache.commons.math.exception.util.LocalizedFormats;
import org.apache.commons.math.util.MathUtils;
import org.apache.commons.math.util.FastMath;

/**
 * Representation of a Complex number - a number which has both a
 * real and imaginary part.
 * &lt;p&gt;
 * Implementations of arithmetic operations handle &lt;code&gt;NaN&lt;/code&gt; and
 * infinite values according to the rules for {@link java.lang.Double}
 * arithmetic, applying definitional formulas and returning &lt;code&gt;NaN&lt;/code&gt; or
 * infinite values in real or imaginary parts as these arise in computation.
 * See individual method javadocs for details.&lt;/p&gt;
 * &lt;p&gt;
 * {@link #equals} identifies all values with &lt;code&gt;NaN&lt;/code&gt; in either real
 * or imaginary part - e.g., &lt;pre&gt;
 * &lt;code&gt;1 + NaNi  == NaN + i == NaN + NaNi.&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
 *
 * implements Serializable since 2.0
 *
 * @version $Revision$ $Date$
 */
public class Complex implements FieldElement&lt;Complex&gt;, Serializable  {

    /** The square root of -1. A number representing &quot;0.0 + 1.0i&quot; */
<span class="fc" id="L51">    public static final Complex I = new Complex(0.0, 1.0);</span>

    // CHECKSTYLE: stop ConstantName
    /** A complex number representing &quot;NaN + NaNi&quot; */
<span class="fc" id="L55">    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);</span>
    // CHECKSTYLE: resume ConstantName

    /** A complex number representing &quot;+INF + INFi&quot; */
<span class="fc" id="L59">    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);</span>

    /** A complex number representing &quot;1.0 + 0.0i&quot; */
<span class="fc" id="L62">    public static final Complex ONE = new Complex(1.0, 0.0);</span>

    /** A complex number representing &quot;0.0 + 0.0i&quot; */
<span class="fc" id="L65">    public static final Complex ZERO = new Complex(0.0, 0.0);</span>

    /** Serializable version identifier */
    private static final long serialVersionUID = -6195664516687396620L;

    /** The imaginary part. */
    private final double imaginary;

    /** The real part. */
    private final double real;

    /** Record whether this complex number is equal to NaN. */
    private final transient boolean isNaN;

    /** Record whether this complex number is infinite. */
    private final transient boolean isInfinite;

    /**
     * Create a complex number given the real and imaginary parts.
     *
     * @param real the real part
     * @param imaginary the imaginary part
     */
    public Complex(double real, double imaginary) {
<span class="fc" id="L89">        super();</span>
<span class="fc" id="L90">        this.real = real;</span>
<span class="fc" id="L91">        this.imaginary = imaginary;</span>

<span class="fc bfc" id="L93" title="All 4 branches covered.">        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        isInfinite = !isNaN &amp;&amp;</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">        (Double.isInfinite(real) || Double.isInfinite(imaginary));</span>
<span class="fc" id="L96">    }</span>

    /**
     * Return the absolute value of this complex number.
     * &lt;p&gt;
     * Returns &lt;code&gt;NaN&lt;/code&gt; if either real or imaginary part is
     * &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Double.POSITIVE_INFINITY&lt;/code&gt; if
     * neither part is &lt;code&gt;NaN&lt;/code&gt;, but at least one part takes an infinite
     * value.&lt;/p&gt;
     *
     * @return the absolute value
     */
    public double abs() {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L110">            return Double.NaN;</span>
        }

<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (isInfinite()) {</span>
<span class="fc" id="L114">            return Double.POSITIVE_INFINITY;</span>
        }

<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (FastMath.abs(real) &lt; FastMath.abs(imaginary)) {</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if (imaginary == 0.0) {</span>
<span class="nc" id="L119">                return FastMath.abs(real);</span>
            }
<span class="fc" id="L121">            double q = real / imaginary;</span>
<span class="fc" id="L122">            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);</span>
        } else {
<span class="fc bfc" id="L124" title="All 2 branches covered.">            if (real == 0.0) {</span>
<span class="fc" id="L125">                return FastMath.abs(imaginary);</span>
            }
<span class="fc" id="L127">            double q = imaginary / real;</span>
<span class="fc" id="L128">            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);</span>
        }
    }

    /**
     * Return the sum of this complex number and the given complex number.
     * &lt;p&gt;
     * Uses the definitional formula
     * &lt;pre&gt;
     * (a + bi) + (c + di) = (a+c) + (b+d)i
     * &lt;/pre&gt;&lt;/p&gt;
     * &lt;p&gt;
     * If either this or &lt;code&gt;rhs&lt;/code&gt; has a NaN value in either part,
     * {@link #NaN} is returned; otherwise Inifinite and NaN values are
     * returned in the parts of the result according to the rules for
     * {@link java.lang.Double} arithmetic.&lt;/p&gt;
     *
     * @param rhs the other complex number
     * @return the complex number sum
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public Complex add(Complex rhs) {
<span class="fc" id="L150">        return createComplex(real + rhs.getReal(),</span>
<span class="fc" id="L151">            imaginary + rhs.getImaginary());</span>
    }

    /**
     * Return the conjugate of this complex number. The conjugate of
     * &quot;A + Bi&quot; is &quot;A - Bi&quot;.
     * &lt;p&gt;
     * {@link #NaN} is returned if either the real or imaginary
     * part of this Complex number equals &lt;code&gt;Double.NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * If the imaginary part is infinite, and the real part is not NaN,
     * the returned value has infinite imaginary part of the opposite
     * sign - e.g. the conjugate of &lt;code&gt;1 + POSITIVE_INFINITY i&lt;/code&gt;
     * is &lt;code&gt;1 - NEGATIVE_INFINITY i&lt;/code&gt;&lt;/p&gt;
     *
     * @return the conjugate of this Complex object
     */
    public Complex conjugate() {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L170">            return NaN;</span>
        }
<span class="fc" id="L172">        return createComplex(real, -imaginary);</span>
    }

    /**
     * Return the quotient of this complex number and the given complex number.
     * &lt;p&gt;
     * Implements the definitional formula
     * &lt;pre&gt;&lt;code&gt;
     *    a + bi          ac + bd + (bc - ad)i
     *    ----------- = -------------------------
     *    c + di         c&lt;sup&gt;2&lt;/sup&gt; + d&lt;sup&gt;2&lt;/sup&gt;
     * &lt;/code&gt;&lt;/pre&gt;
     * but uses
     * &lt;a href=&quot;http://doi.acm.org/10.1145/1039813.1039814&quot;&gt;
     * prescaling of operands&lt;/a&gt; to limit the effects of overflows and
     * underflows in the computation.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite and NaN values are handled / returned according to the
     * following rules, applied in the order presented:
     * &lt;ul&gt;
     * &lt;li&gt;If either this or &lt;code&gt;rhs&lt;/code&gt; has a NaN value in either part,
     *  {@link #NaN} is returned.&lt;/li&gt;
     * &lt;li&gt;If &lt;code&gt;rhs&lt;/code&gt; equals {@link #ZERO}, {@link #NaN} is returned.
     * &lt;/li&gt;
     * &lt;li&gt;If this and &lt;code&gt;rhs&lt;/code&gt; are both infinite,
     * {@link #NaN} is returned.&lt;/li&gt;
     * &lt;li&gt;If this is finite (i.e., has no infinite or NaN parts) and
     *  &lt;code&gt;rhs&lt;/code&gt; is infinite (one or both parts infinite),
     * {@link #ZERO} is returned.&lt;/li&gt;
     * &lt;li&gt;If this is infinite and &lt;code&gt;rhs&lt;/code&gt; is finite, NaN values are
     * returned in the parts of the result if the {@link java.lang.Double}
     * rules applied to the definitional formula force NaN results.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/p&gt;
     *
     * @param rhs the other complex number
     * @return the complex number quotient
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public Complex divide(Complex rhs) {
<span class="pc bpc" id="L211" title="1 of 4 branches missed.">        if (isNaN() || rhs.isNaN()) {</span>
<span class="fc" id="L212">            return NaN;</span>
        }

<span class="fc" id="L215">        double c = rhs.getReal();</span>
<span class="fc" id="L216">        double d = rhs.getImaginary();</span>
<span class="fc bfc" id="L217" title="All 4 branches covered.">        if (c == 0.0 &amp;&amp; d == 0.0) {</span>
<span class="fc" id="L218">            return NaN;</span>
        }

<span class="fc bfc" id="L221" title="All 4 branches covered.">        if (rhs.isInfinite() &amp;&amp; !isInfinite()) {</span>
<span class="fc" id="L222">            return ZERO;</span>
        }

<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (FastMath.abs(c) &lt; FastMath.abs(d)) {</span>
<span class="fc" id="L226">            double q = c / d;</span>
<span class="fc" id="L227">            double denominator = c * q + d;</span>
<span class="fc" id="L228">            return createComplex((real * q + imaginary) / denominator,</span>
                (imaginary * q - real) / denominator);
        } else {
<span class="fc" id="L231">            double q = d / c;</span>
<span class="fc" id="L232">            double denominator = d * q + c;</span>
<span class="fc" id="L233">            return createComplex((imaginary * q + real) / denominator,</span>
                (imaginary - real * q) / denominator);
        }
    }

    /**
     * Test for the equality of two Complex objects.
     * &lt;p&gt;
     * If both the real and imaginary parts of two Complex numbers
     * are exactly the same, and neither is &lt;code&gt;Double.NaN&lt;/code&gt;, the two
     * Complex objects are considered to be equal.&lt;/p&gt;
     * &lt;p&gt;
     * All &lt;code&gt;NaN&lt;/code&gt; values are considered to be equal - i.e, if either
     * (or both) real and imaginary parts of the complex number are equal
     * to &lt;code&gt;Double.NaN&lt;/code&gt;, the complex number is equal to
     * &lt;code&gt;Complex.NaN&lt;/code&gt;.&lt;/p&gt;
     *
     * @param other Object to test for equality to this
     * @return true if two Complex objects are equal, false if
     *         object is null, not an instance of Complex, or
     *         not equal to this Complex instance
     *
     */
    @Override
    public boolean equals(Object other) {
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (this == other) {</span>
<span class="fc" id="L259">            return true;</span>
        }
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (other instanceof Complex){</span>
<span class="fc" id="L262">            Complex rhs = (Complex)other;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (rhs.isNaN()) {</span>
<span class="fc" id="L264">                return this.isNaN();</span>
            } else {
<span class="fc bfc" id="L266" title="All 4 branches covered.">                return (real == rhs.real) &amp;&amp; (imaginary == rhs.imaginary);</span>
            }
        }
<span class="fc" id="L269">        return false;</span>
    }

    /**
     * Get a hashCode for the complex number.
     * &lt;p&gt;
     * All NaN values have the same hash code.&lt;/p&gt;
     *
     * @return a hash code value for this object
     */
    @Override
    public int hashCode() {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L282">            return 7;</span>
        }
<span class="fc" id="L284">        return 37 * (17 * MathUtils.hash(imaginary) +</span>
<span class="fc" id="L285">            MathUtils.hash(real));</span>
    }

    /**
     * Access the imaginary part.
     *
     * @return the imaginary part
     */
    public double getImaginary() {
<span class="fc" id="L294">        return imaginary;</span>
    }

    /**
     * Access the real part.
     *
     * @return the real part
     */
    public double getReal() {
<span class="fc" id="L303">        return real;</span>
    }

    /**
     * Returns true if either or both parts of this complex number is NaN;
     * false otherwise
     *
     * @return  true if either or both parts of this complex number is NaN;
     * false otherwise
     */
    public boolean isNaN() {
<span class="fc" id="L314">        return isNaN;</span>
    }

    /**
     * Returns true if either the real or imaginary part of this complex number
     * takes an infinite value (either &lt;code&gt;Double.POSITIVE_INFINITY&lt;/code&gt; or
     * &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt;) and neither part
     * is &lt;code&gt;NaN&lt;/code&gt;.
     *
     * @return true if one or both parts of this complex number are infinite
     * and neither part is &lt;code&gt;NaN&lt;/code&gt;
     */
    public boolean isInfinite() {
<span class="fc" id="L327">        return isInfinite;</span>
    }

    /**
     * Return the product of this complex number and the given complex number.
     * &lt;p&gt;
     * Implements preliminary checks for NaN and infinity followed by
     * the definitional formula:
     * &lt;pre&gt;&lt;code&gt;
     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link #NaN} if either this or &lt;code&gt;rhs&lt;/code&gt; has one or more
     * NaN parts.
     * &lt;/p&gt;
     * Returns {@link #INF} if neither this nor &lt;code&gt;rhs&lt;/code&gt; has one or more
     * NaN parts and if either this or &lt;code&gt;rhs&lt;/code&gt; has one or more
     * infinite parts (same result is returned regardless of the sign of the
     * components).
     * &lt;/p&gt;
     * &lt;p&gt;
     * Returns finite values in components of the result per the
     * definitional formula in all remaining cases.
     *  &lt;/p&gt;
     *
     * @param rhs the other complex number
     * @return the complex number product
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public Complex multiply(Complex rhs) {
<span class="fc bfc" id="L358" title="All 4 branches covered.">        if (isNaN() || rhs.isNaN()) {</span>
<span class="fc" id="L359">            return NaN;</span>
        }
<span class="fc bfc" id="L361" title="All 4 branches covered.">        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||</span>
<span class="fc bfc" id="L362" title="All 4 branches covered.">            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {</span>
            // we don't use Complex.isInfinite() to avoid testing for NaN again
<span class="fc" id="L364">            return INF;</span>
        }
<span class="fc" id="L366">        return createComplex(real * rhs.real - imaginary * rhs.imaginary,</span>
                real * rhs.imaginary + imaginary * rhs.real);
    }

    /**
     * Return the product of this complex number and the given scalar number.
     * &lt;p&gt;
     * Implements preliminary checks for NaN and infinity followed by
     * the definitional formula:
     * &lt;pre&gt;&lt;code&gt;
     * c(a + bi) = (ca) + (cb)i
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link #NaN} if either this or &lt;code&gt;rhs&lt;/code&gt; has one or more
     * NaN parts.
     * &lt;/p&gt;
     * Returns {@link #INF} if neither this nor &lt;code&gt;rhs&lt;/code&gt; has one or more
     * NaN parts and if either this or &lt;code&gt;rhs&lt;/code&gt; has one or more
     * infinite parts (same result is returned regardless of the sign of the
     * components).
     * &lt;/p&gt;
     * &lt;p&gt;
     * Returns finite values in components of the result per the
     * definitional formula in all remaining cases.
     *  &lt;/p&gt;
     *
     * @param rhs the scalar number
     * @return the complex number product
     */
    public Complex multiply(double rhs) {
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">        if (isNaN() || Double.isNaN(rhs)) {</span>
<span class="fc" id="L398">            return NaN;</span>
        }
<span class="pc bpc" id="L400" title="2 of 4 branches missed.">        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            Double.isInfinite(rhs)) {</span>
            // we don't use Complex.isInfinite() to avoid testing for NaN again
<span class="fc" id="L403">            return INF;</span>
        }
<span class="fc" id="L405">        return createComplex(real * rhs, imaginary * rhs);</span>
    }

    /**
     * Return the additive inverse of this complex number.
     * &lt;p&gt;
     * Returns &lt;code&gt;Complex.NaN&lt;/code&gt; if either real or imaginary
     * part of this Complex number equals &lt;code&gt;Double.NaN&lt;/code&gt;.&lt;/p&gt;
     *
     * @return the negation of this complex number
     */
    public Complex negate() {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L418">            return NaN;</span>
        }

<span class="fc" id="L421">        return createComplex(-real, -imaginary);</span>
    }

    /**
     * Return the difference between this complex number and the given complex
     * number.
      * &lt;p&gt;
     * Uses the definitional formula
     * &lt;pre&gt;
     * (a + bi) - (c + di) = (a-c) + (b-d)i
     * &lt;/pre&gt;&lt;/p&gt;
     * &lt;p&gt;
     * If either this or &lt;code&gt;rhs&lt;/code&gt; has a NaN value in either part,
     * {@link #NaN} is returned; otherwise inifinite and NaN values are
     * returned in the parts of the result according to the rules for
     * {@link java.lang.Double} arithmetic. &lt;/p&gt;
     *
     * @param rhs the other complex number
     * @return the complex number difference
     * @throws NullPointerException if &lt;code&gt;rhs&lt;/code&gt; is null
     */
    public Complex subtract(Complex rhs) {
<span class="pc bpc" id="L443" title="1 of 4 branches missed.">        if (isNaN() || rhs.isNaN()) {</span>
<span class="fc" id="L444">            return NaN;</span>
        }

<span class="fc" id="L447">        return createComplex(real - rhs.getReal(),</span>
<span class="fc" id="L448">            imaginary - rhs.getImaginary());</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/InverseCosine.html&quot; TARGET=&quot;_top&quot;&gt;
     * inverse cosine&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; acos(z) = -i (log(z + i (sqrt(1 - z&lt;sup&gt;2&lt;/sup&gt;))))&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt; or infinite.&lt;/p&gt;
     *
     * @return the inverse cosine of this complex number
     * @since 1.2
     */
    public Complex acos() {
<span class="fc bfc" id="L466" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L467">            return Complex.NaN;</span>
        }

<span class="fc" id="L470">        return this.add(this.sqrt1z().multiply(Complex.I)).log()</span>
<span class="fc" id="L471">              .multiply(Complex.I.negate());</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/InverseSine.html&quot; TARGET=&quot;_top&quot;&gt;
     * inverse sine&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; asin(z) = -i (log(sqrt(1 - z&lt;sup&gt;2&lt;/sup&gt;) + iz)) &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt; or infinite.&lt;/p&gt;
     *
     * @return the inverse sine of this complex number.
     * @since 1.2
     */
    public Complex asin() {
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L490">            return Complex.NaN;</span>
        }

<span class="fc" id="L493">        return sqrt1z().add(this.multiply(Complex.I)).log()</span>
<span class="fc" id="L494">              .multiply(Complex.I.negate());</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/InverseTangent.html&quot; TARGET=&quot;_top&quot;&gt;
     * inverse tangent&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; atan(z) = (i/2) log((i + z)/(i - z)) &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt; or infinite.&lt;/p&gt;
     *
     * @return the inverse tangent of this complex number
     * @since 1.2
     */
    public Complex atan() {
<span class="fc bfc" id="L512" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L513">            return Complex.NaN;</span>
        }

<span class="fc" id="L516">        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()</span>
<span class="fc" id="L517">            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/Cosine.html&quot; TARGET=&quot;_top&quot;&gt;
     * cosine&lt;/a&gt;
     * of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i&lt;/code&gt;&lt;/pre&gt;
     * where the (real) functions on the right-hand side are
     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * cos(1 &amp;plusmn; INFINITY i) = 1 &amp;#x2213; INFINITY i
     * cos(&amp;plusmn;INFINITY + i) = NaN + NaN i
     * cos(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return the cosine of this complex number
     * @since 1.2
     */
    public Complex cos() {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L548">            return Complex.NaN;</span>
        }

<span class="fc" id="L551">        return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),</span>
<span class="fc" id="L552">            -FastMath.sin(real) * MathUtils.sinh(imaginary));</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicCosine.html&quot; TARGET=&quot;_top&quot;&gt;
     * hyperbolic cosine&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i&lt;/code&gt;&lt;/pre&gt;
     * where the (real) functions on the right-hand side are
     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * cosh(1 &amp;plusmn; INFINITY i) = NaN + NaN i
     * cosh(&amp;plusmn;INFINITY + i) = INFINITY &amp;plusmn; INFINITY i
     * cosh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return the hyperbolic cosine of this complex number.
     * @since 1.2
     */
    public Complex cosh() {
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L582">            return Complex.NaN;</span>
        }

<span class="fc" id="L585">        return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),</span>
<span class="fc" id="L586">            MathUtils.sinh(real) * FastMath.sin(imaginary));</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/ExponentialFunction.html&quot; TARGET=&quot;_top&quot;&gt;
     * exponential function&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i&lt;/code&gt;&lt;/pre&gt;
     * where the (real) functions on the right-hand side are
     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
     * {@link java.lang.Math#sin}.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * exp(1 &amp;plusmn; INFINITY i) = NaN + NaN i
     * exp(INFINITY + i) = INFINITY + INFINITY i
     * exp(-INFINITY + i) = 0 + 0i
     * exp(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;&lt;code&gt;this&lt;/code&gt;&lt;/sup&gt;
     * @since 1.2
     */
    public Complex exp() {
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L617">            return Complex.NaN;</span>
        }

<span class="fc" id="L620">        double expReal = FastMath.exp(real);</span>
<span class="fc" id="L621">        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/NaturalLogarithm.html&quot; TARGET=&quot;_top&quot;&gt;
     * natural logarithm&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; log(a + bi) = ln(|a + bi|) + arg(a + bi)i&lt;/code&gt;&lt;/pre&gt;
     * where ln on the right hand side is {@link java.lang.Math#log},
     * &lt;code&gt;|a + bi|&lt;/code&gt; is the modulus, {@link Complex#abs},  and
     * &lt;code&gt;arg(a + bi) = {@link java.lang.Math#atan2}(b, a)&lt;/code&gt;&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite (or critical) values in real or imaginary parts of the input may
     * result in infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * log(1 &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (&amp;pi;/2)i
     * log(INFINITY + i) = INFINITY + 0i
     * log(-INFINITY + i) = INFINITY + &amp;pi;i
     * log(INFINITY &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (&amp;pi;/4)i
     * log(-INFINITY &amp;plusmn; INFINITY i) = INFINITY &amp;plusmn; (3&amp;pi;/4)i
     * log(0 + 0i) = -INFINITY + 0i
     * &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return ln of this complex number.
     * @since 1.2
     */
    public Complex log() {
<span class="fc bfc" id="L654" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L655">            return Complex.NaN;</span>
        }

<span class="fc" id="L658">        return createComplex(FastMath.log(abs()),</span>
<span class="fc" id="L659">            FastMath.atan2(imaginary, real));</span>
    }

    /**
     * Returns of value of this complex number raised to the power of &lt;code&gt;x&lt;/code&gt;.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; y&lt;sup&gt;x&lt;/sup&gt; = exp(x&amp;middot;log(y))&lt;/code&gt;&lt;/pre&gt;
     * where &lt;code&gt;exp&lt;/code&gt; and &lt;code&gt;log&lt;/code&gt; are {@link #exp} and
     * {@link #log}, respectively.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt; or infinite, or if &lt;code&gt;y&lt;/code&gt;
     * equals {@link Complex#ZERO}.&lt;/p&gt;
     *
     * @param x the exponent.
     * @return &lt;code&gt;this&lt;/code&gt;&lt;sup&gt;&lt;code&gt;x&lt;/code&gt;&lt;/sup&gt;
     * @throws NullPointerException if x is null
     * @since 1.2
     */
    public Complex pow(Complex x) {
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (x == null) {</span>
<span class="fc" id="L681">            throw new NullPointerException();</span>
        }
<span class="fc" id="L683">        return this.log().multiply(x).exp();</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/Sine.html&quot; TARGET=&quot;_top&quot;&gt;
     * sine&lt;/a&gt;
     * of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i&lt;/code&gt;&lt;/pre&gt;
     * where the (real) functions on the right-hand side are
     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * sin(1 &amp;plusmn; INFINITY i) = 1 &amp;plusmn; INFINITY i
     * sin(&amp;plusmn;INFINITY + i) = NaN + NaN i
     * sin(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return the sine of this complex number.
     * @since 1.2
     */
    public Complex sin() {
<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L714">            return Complex.NaN;</span>
        }

<span class="fc" id="L717">        return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),</span>
<span class="fc" id="L718">            FastMath.cos(real) * MathUtils.sinh(imaginary));</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicSine.html&quot; TARGET=&quot;_top&quot;&gt;
     * hyperbolic sine&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt; sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i&lt;/code&gt;&lt;/pre&gt;
     * where the (real) functions on the right-hand side are
     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * sinh(1 &amp;plusmn; INFINITY i) = NaN + NaN i
     * sinh(&amp;plusmn;INFINITY + i) = &amp;plusmn; INFINITY + INFINITY i
     * sinh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return the hyperbolic sine of this complex number
     * @since 1.2
     */
    public Complex sinh() {
<span class="fc bfc" id="L747" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L748">            return Complex.NaN;</span>
        }

<span class="fc" id="L751">        return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),</span>
<span class="fc" id="L752">            MathUtils.cosh(real) * FastMath.sin(imaginary));</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/SquareRoot.html&quot; TARGET=&quot;_top&quot;&gt;
     * square root&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the following algorithm to compute &lt;code&gt;sqrt(a + bi)&lt;/code&gt;:
     * &lt;ol&gt;&lt;li&gt;Let &lt;code&gt;t = sqrt((|a| + |a + bi|) / 2)&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;pre&gt;if &lt;code&gt; a &amp;#8805; 0&lt;/code&gt; return &lt;code&gt;t + (b/2t)i&lt;/code&gt;
     *  else return &lt;code&gt;|b|/2t + sign(b)t i &lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
     * &lt;/ol&gt;
     * where &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;|a| = {@link Math#abs}(a)&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;|a + bi| = {@link Complex#abs}(a + bi) &lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;sign(b) =  {@link MathUtils#indicator}(b) &lt;/code&gt;
     * &lt;/ul&gt;&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * sqrt(1 &amp;plusmn; INFINITY i) = INFINITY + NaN i
     * sqrt(INFINITY + i) = INFINITY + 0i
     * sqrt(-INFINITY + i) = 0 + INFINITY i
     * sqrt(INFINITY &amp;plusmn; INFINITY i) = INFINITY + NaN i
     * sqrt(-INFINITY &amp;plusmn; INFINITY i) = NaN &amp;plusmn; INFINITY i
     * &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return the square root of this complex number
     * @since 1.2
     */
    public Complex sqrt() {
<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L790">            return Complex.NaN;</span>
        }

<span class="fc bfc" id="L793" title="All 4 branches covered.">        if (real == 0.0 &amp;&amp; imaginary == 0.0) {</span>
<span class="fc" id="L794">            return createComplex(0.0, 0.0);</span>
        }

<span class="fc" id="L797">        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">        if (real &gt;= 0.0) {</span>
<span class="fc" id="L799">            return createComplex(t, imaginary / (2.0 * t));</span>
        } else {
<span class="fc" id="L801">            return createComplex(FastMath.abs(imaginary) / (2.0 * t),</span>
<span class="fc" id="L802">                MathUtils.indicator(imaginary) * t);</span>
        }
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/SquareRoot.html&quot; TARGET=&quot;_top&quot;&gt;
     * square root&lt;/a&gt; of 1 - &lt;code&gt;this&lt;/code&gt;&lt;sup&gt;2&lt;/sup&gt; for this complex
     * number.
     * &lt;p&gt;
     * Computes the result directly as
     * &lt;code&gt;sqrt(Complex.ONE.subtract(z.multiply(z)))&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;/p&gt;
     *
     * @return the square root of 1 - &lt;code&gt;this&lt;/code&gt;&lt;sup&gt;2&lt;/sup&gt;
     * @since 1.2
     */
    public Complex sqrt1z() {
<span class="fc" id="L825">        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/Tangent.html&quot; TARGET=&quot;_top&quot;&gt;
     * tangent&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt;tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i&lt;/code&gt;&lt;/pre&gt;
     * where the (real) functions on the right-hand side are
     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite (or critical) values in real or imaginary parts of the input may
     * result in infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * tan(1 &amp;plusmn; INFINITY i) = 0 + NaN i
     * tan(&amp;plusmn;INFINITY + i) = NaN + NaN i
     * tan(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
     * tan(&amp;plusmn;&amp;pi;/2 + 0 i) = &amp;plusmn;INFINITY + NaN i&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return the tangent of this complex number
     * @since 1.2
     */
    public Complex tan() {
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L856">            return Complex.NaN;</span>
        }

<span class="fc" id="L859">        double real2 = 2.0 * real;</span>
<span class="fc" id="L860">        double imaginary2 = 2.0 * imaginary;</span>
<span class="fc" id="L861">        double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);</span>

<span class="fc" id="L863">        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);</span>
    }

    /**
     * Compute the
     * &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicTangent.html&quot; TARGET=&quot;_top&quot;&gt;
     * hyperbolic tangent&lt;/a&gt; of this complex number.
     * &lt;p&gt;
     * Implements the formula: &lt;pre&gt;
     * &lt;code&gt;tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i&lt;/code&gt;&lt;/pre&gt;
     * where the (real) functions on the right-hand side are
     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.&lt;/p&gt;
     * &lt;p&gt;
     * Returns {@link Complex#NaN} if either real or imaginary part of the
     * input argument is &lt;code&gt;NaN&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;
     * Infinite values in real or imaginary parts of the input may result in
     * infinite or NaN values returned in parts of the result.&lt;pre&gt;
     * Examples:
     * &lt;code&gt;
     * tanh(1 &amp;plusmn; INFINITY i) = NaN + NaN i
     * tanh(&amp;plusmn;INFINITY + i) = NaN + 0 i
     * tanh(&amp;plusmn;INFINITY &amp;plusmn; INFINITY i) = NaN + NaN i
     * tanh(0 + (&amp;pi;/2)i) = NaN + INFINITY i&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
     *
     * @return the hyperbolic tangent of this complex number
     * @since 1.2
     */
    public Complex tanh() {
<span class="fc bfc" id="L893" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L894">            return Complex.NaN;</span>
        }

<span class="fc" id="L897">        double real2 = 2.0 * real;</span>
<span class="fc" id="L898">        double imaginary2 = 2.0 * imaginary;</span>
<span class="fc" id="L899">        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);</span>

<span class="fc" id="L901">        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);</span>
    }



    /**
     * &lt;p&gt;Compute the argument of this complex number.
     * &lt;/p&gt;
     * &lt;p&gt;The argument is the angle phi between the positive real axis and the point
     * representing this number in the complex plane. The value returned is between -PI (not inclusive)
     * and PI (inclusive), with negative values returned for numbers with negative imaginary parts.
     * &lt;/p&gt;
     * &lt;p&gt;If either real or imaginary part (or both) is NaN, NaN is returned.  Infinite parts are handled
     * as java.Math.atan2 handles them, essentially treating finite parts as zero in the presence of
     * an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite
     * parts.  See the javadoc for java.Math.atan2 for full details.&lt;/p&gt;
     *
     * @return the argument of this complex number
     */
    public double getArgument() {
<span class="fc" id="L921">        return FastMath.atan2(getImaginary(), getReal());</span>
    }

    /**
     * &lt;p&gt;Computes the n-th roots of this complex number.
     * &lt;/p&gt;
     * &lt;p&gt;The nth roots are defined by the formula: &lt;pre&gt;
     * &lt;code&gt; z&lt;sub&gt;k&lt;/sub&gt; = abs&lt;sup&gt; 1/n&lt;/sup&gt; (cos(phi + 2&amp;pi;k/n) + i (sin(phi + 2&amp;pi;k/n))&lt;/code&gt;&lt;/pre&gt;
     * for &lt;i&gt;&lt;code&gt;k=0, 1, ..., n-1&lt;/code&gt;&lt;/i&gt;, where &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;phi&lt;/code&gt; are
     * respectively the {@link #abs() modulus} and {@link #getArgument() argument} of this complex number.
     * &lt;/p&gt;
     * &lt;p&gt;If one or both parts of this complex number is NaN, a list with just one element,
     *  {@link #NaN} is returned.&lt;/p&gt;
     * &lt;p&gt;if neither part is NaN, but at least one part is infinite, the result is a one-element
     * list containing {@link #INF}.&lt;/p&gt;
     *
     * @param n degree of root
     * @return List&lt;Complex&gt; all nth roots of this complex number
     * @throws IllegalArgumentException if parameter n is less than or equal to 0
     * @since 2.0
     */
    public List&lt;Complex&gt; nthRoot(int n) throws IllegalArgumentException {

<span class="pc bpc" id="L944" title="1 of 2 branches missed.">        if (n &lt;= 0) {</span>
<span class="nc" id="L945">            throw MathRuntimeException.createIllegalArgumentException(</span>
                    LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,
<span class="nc" id="L947">                    n);</span>
        }

<span class="fc" id="L950">        List&lt;Complex&gt; result = new ArrayList&lt;Complex&gt;();</span>

<span class="fc bfc" id="L952" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L953">            result.add(Complex.NaN);</span>
<span class="fc" id="L954">            return result;</span>
        }

<span class="fc bfc" id="L957" title="All 2 branches covered.">        if (isInfinite()) {</span>
<span class="fc" id="L958">            result.add(Complex.INF);</span>
<span class="fc" id="L959">            return result;</span>
        }

        // nth root of abs -- faster / more accurate to use a solver here?
<span class="fc" id="L963">        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);</span>

        // Compute nth roots of complex number with k = 0, 1, ... n-1
<span class="fc" id="L966">        final double nthPhi = getArgument()/n;</span>
<span class="fc" id="L967">        final double slice = 2 * FastMath.PI / n;</span>
<span class="fc" id="L968">        double innerPart = nthPhi;</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        for (int k = 0; k &lt; n ; k++) {</span>
            // inner part
<span class="fc" id="L971">            final double realPart      = nthRootOfAbs *  FastMath.cos(innerPart);</span>
<span class="fc" id="L972">            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);</span>
<span class="fc" id="L973">            result.add(createComplex(realPart, imaginaryPart));</span>
<span class="fc" id="L974">            innerPart += slice;</span>
        }

<span class="fc" id="L977">        return result;</span>
    }

    /**
     * Create a complex number given the real and imaginary parts.
     *
     * @param realPart the real part
     * @param imaginaryPart the imaginary part
     * @return a new complex number instance
     * @since 1.2
     */
    protected Complex createComplex(double realPart, double imaginaryPart) {
<span class="fc" id="L989">        return new Complex(realPart, imaginaryPart);</span>
    }

    /**
     * &lt;p&gt;Resolve the transient fields in a deserialized Complex Object.&lt;/p&gt;
     * &lt;p&gt;Subclasses will need to override {@link #createComplex} to deserialize properly&lt;/p&gt;
     * @return A Complex instance with all fields resolved.
     * @since 2.0
     */
    protected final Object readResolve() {
<span class="fc" id="L999">        return createComplex(real, imaginary);</span>
    }

    /** {@inheritDoc} */
    public ComplexField getField() {
<span class="nc" id="L1004">        return ComplexField.getInstance();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>